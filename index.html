<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0ea5e9" />
  <link rel="manifest" href="manifest.json" />

    <!-- iOS home-screen icon(s) -->
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon-180.png">

  <!-- Optional: the name shown under the icon on iOS -->
  <meta name="apple-mobile-web-app-title" content="Macro App">

  <!-- Optional: open as a standalone app on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  
  <title>Macro App ‚Äî Meals + Open Food Facts</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 720px; }
    h1 { margin-bottom: .25rem; }
    .muted { color:#555; font-size:.9rem; margin-bottom:1rem; }
    .row { display:grid; grid-template-columns: 1fr 1.2fr 1fr 1fr auto; gap:.5rem; align-items:end; }
    label { font-size:.9rem; }
    input, select { width:100%; padding:.55rem; border:1px solid #ccc; border-radius:.5rem; }
    button { padding:.6rem 1rem; border:1px solid #ddd; border-radius:.7rem; cursor:pointer; background:#fff; }
    .card { padding:1rem; border:1px solid #ddd; border-radius:.75rem; margin-bottom:1rem; }
    table { width:100%; border-collapse: collapse; margin-top:.5rem; }
    th, td { padding:.5rem; border-bottom:1px solid #eee; text-align:left; }
    th.right, td.right { text-align:right; }
    .totals { background:#f7f7f7; border-radius:.5rem; padding:.6rem .8rem; margin-top:.5rem; }
    .meal-title { display:flex; justify-content:space-between; align-items:center; }
    .pill { font-size:.8rem; padding:.2rem .5rem; border:1px solid #ddd; border-radius:999px; background:#fff; }
    .hint { font-size:.8rem; color:#666; margin-top:.25rem; }
    .error { color:#b00020; font-size:.9rem; }
  </style>
</head>
<body>
  <h1>üçΩÔ∏è Macro Counter ‚Äî Meals (OFF)</h1>
  <p class="muted">
    Pick a meal (1‚Äì6). Start typing a food (we query Open Food Facts), choose a portion or grams, then <strong>Add</strong>.
    Works offline; when offline we use a tiny built-in list.
  </p>

  <div class="card">
    <div class="row">
      <div>
        <label>Meal</label>
        <select id="meal">
          <option value="0">Meal 1</option><option value="1">Meal 2</option>
          <option value="2">Meal 3</option><option value="3">Meal 4</option>
          <option value="4">Meal 5</option><option value="5">Meal 6</option>
        </select>
      </div>

      <div>
        <label>Food</label>
        <input id="foodInput" list="foodlist" placeholder="e.g., banana, oats, pasta cooked">
        <datalist id="foodlist"></datalist>
        <div id="netMsg" class="hint"></div>
      </div>

      <div>
        <label>Portion</label>
        <select id="portion"></select>
      </div>

      <div>
        <label>Grams</label>
        <input id="grams" type="number" min="1" step="1" value="100">
      </div>

      <div>
        <button id="addBtn">Add</button>
      </div>
    </div>

    <div id="preview" class="totals" style="display:none;"></div>
    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div id="meals"></div>

  <div class="card">
    <div class="meal-title">
      <strong>Day total</strong>
      <button id="resetDay" class="pill">Reset today</button>
    </div>
    <div id="dayTotal" class="totals"></div>
  </div>

  <script>
    // ---------- Helpers ----------
    const $ = id => document.getElementById(id);
    const todayKey = () => 'meals-' + new Date().toISOString().slice(0,10);
    const kcal = (p,c,f) => Math.round(p*4 + c*4 + f*9);
    const round1 = x => Math.round(x*10)/10;
    const online = () => navigator.onLine;

    function defaultDay(){ return { meals:[[],[],[],[],[],[]] }; }
    function loadDay(){ try{ return JSON.parse(localStorage.getItem(todayKey())) || defaultDay(); } catch { return defaultDay(); } }
    function saveDay(data){ localStorage.setItem(todayKey(), JSON.stringify(data)); }

    // Built-in fallback foods (used when offline or API fails)
    const FALLBACK_FOODS = [
      {name:'Banana', p:1.1, c:23.0, f:0.3, portions:[{label:'100 g',g:100},{label:'1 medium (118 g)',g:118}]},
      {name:'Oats (dry)', p:13.2, c:67.7, f:6.5, portions:[{label:'100 g',g:100},{label:'Bowl (60 g)',g:60}]},
      {name:'Pasta (cooked)', p:5.8, c:30.0, f:1.1, portions:[{label:'100 g',g:100},{label:'Plate (250 g)',g:250}]}
    ];

    // ---------- Open Food Facts search ----------
const OFF_BASE = 'https://world.openfoodfacts.org/cgi/search.pl';
let lastResults = []; // latest suggestions for current query

// Make a nice label and normalize nutriments (per 100g)
function normalizeProduct(p){
  const name = (p.product_name || 'Unnamed').trim();
  const brand = (p.brands || '').split(',')[0]?.trim();
  const label = brand ? `${name} ‚Äî ${brand}` : name;

  const n = p.nutriments || {};
  const p100 = Number(n.proteins_100g) || 0;
  const c100 = Number(n.carbohydrates_100g) || 0;
  const f100 = Number(n.fat_100g) || 0;
  let kcal100 = Number(n['energy-kcal_100g']);
  if (!kcal100 && (p100||c100||f100)) kcal100 = Math.round(p100*4 + c100*4 + f100*9);

  // Parse serving size like "150 g" if present
  let servingG = null;
  const ss = (p.serving_size || '').toLowerCase();
  const m = ss.match(/([\d.]+)\s*g/);
  if (m) servingG = Number(m[1]);

  const portions = [{label:'100 g', g:100}];
  if (servingG) portions.unshift({label:`1 serving (${servingG} g)`, g:servingG});

  return { code:p.code, label, name, gramsDefault: servingG || 100, p100, c100, f100, kcal100: kcal100||null, portions };
}

// Debounce helper so we don't spam the API while typing
function debounce(fn, ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

// v1 search endpoint (supports free-text "search_terms")
async function searchOFF(query){
  const params = new URLSearchParams({
    search_terms: query,
    search_simple: '1',
    page_size: '12',
    json: '1',
    nocache: '1',
    lc: 'en',
    fields: 'code,product_name,brands,nutriments,serving_size'
  });
  const url = `${OFF_BASE}?${params.toString()}`;
  const res = await fetch(url);
  const data = await res.json();

  const products = (data.products || [])
    .map(normalizeProduct)
    .filter(x => (x.p100 || x.c100 || x.f100)); // keep only items with macros

  lastResults = products;
  return products;
}
// ---------- UI wiring for search + preview ----------

    const foodInput = $('foodInput');
    const foodlist = $('foodlist');
    const portionSel = $('portion');
    const gramsBox = $('grams');
    const previewBox = $('preview');
    const errBox = $('err');
    const netMsg = $('netMsg');

    function fillPortionsPortals(item){
      portionSel.innerHTML = '';
      (item.portions||[{label:'100 g',g:100}]).forEach(p =>
        portionSel.insertAdjacentHTML('beforeend', `<option value="${p.g}">${p.label}</option>`)
      );
      gramsBox.value = item.gramsDefault || (portionSel.value || 100);
    }

    function setPreviewFromItem(item){
      const g = Math.max(1, Number(gramsBox.value)||0);
      const p = item.p100 * g/100, c = item.c100 * g/100, f = item.f100 * g/100;
      previewBox.style.display = 'block';
      previewBox.innerHTML = `<strong>Item preview</strong> ‚Äî ${item.name}, ${g} g<br>
        Protein: ${round1(p)} g ¬∑ Carbs: ${round1(c)} g ¬∑ Fat: ${round1(f)} g<br>
        Calories: ${kcal(p,c,f)} kcal`;
      errBox.style.display = 'none';
    }

    const offlineFind = (name) => {
      const n = String(name||'').toLowerCase();
      return FALLBACK_FOODS.find(f => f.name.toLowerCase().includes(n));
    };

    const doSuggest = debounce(async () => {
      const q = foodInput.value.trim();
      if (!q) { foodlist.innerHTML=''; previewBox.style.display='none'; return; }

      // show network state
      netMsg.textContent = online() ? '' : 'Offline: using built-in foods only';

      try {
        let items = [];
        if (online()) {
          items = await searchOFF(q);
        }
        // Fallback if no API results OR offline
        if (!items.length) {
          const fb = offlineFind(q);
          if (fb) {
            const fake = { code:'fallback', label: fb.name, name: fb.name,
              gramsDefault: (fb.portions[0]?.g)||100,
              p100: fb.p, c100: fb.c, f100: fb.f,
              kcal100: Math.round(fb.p*4 + fb.c*4 + fb.f*9),
              portions: fb.portions
            };
            items = [fake];
            lastResults = items;
          }
        }

        // populate datalist
        foodlist.innerHTML = '';
        items.slice(0,12).forEach(it => {
          const opt = document.createElement('option');
          opt.value = it.label;
          foodlist.appendChild(opt);
        });

        // if we have a first item, preload its portions + preview
        if (items[0]) {
          fillPortionsPortals(items[0]);
          setPreviewFromItem(items[0]);
        } else {
          previewBox.style.display='none';
        }
      } catch (e) {
        errBox.style.display='block';
        errBox.textContent = 'Could not reach Open Food Facts. Using offline list if available.';
        // fallback
        const fb = offlineFind(q);
        if (fb) {
          const fake = { code:'fallback', label: fb.name, name: fb.name,
            gramsDefault: (fb.portions[0]?.g)||100, p100: fb.p, c100: fb.c, f100: fb.f,
            kcal100: Math.round(fb.p*4 + fb.c*4 + fb.f*9), portions: fb.portions
          };
          lastResults = [fake];
          fillPortionsPortals(fake);
          setPreviewFromItem(fake);
        }
      }
    }, 300);

    foodInput.addEventListener('input', doSuggest);
    portionSel.addEventListener('change', () => { gramsBox.value = portionSel.value; if (lastChosen) setPreviewFromItem(lastChosen); });
    gramsBox.addEventListener('input', () => { if (lastChosen) setPreviewFromItem(lastChosen); });

    // when user leaves the input, try to lock on the selected label
    let lastChosen = null;
    foodInput.addEventListener('change', () => {
      const label = foodInput.value.trim();
      const it = lastResults.find(x => x.label === label) || lastResults[0];
      if (it) { lastChosen = it; fillPortionsPortals(it); setPreviewFromItem(it); }
    });

    // ---------- Add item to meal ----------
    function mealTotals(items){
      return items.reduce((t,x)=>({p:t.p+x.p, c:t.c+x.c, f:t.f+x.f, kcal:t.kcal+x.kcal}), {p:0,c:0,f:0,kcal:0});
    }

    function render(){
      const data = loadDay();
      const wrap = $('meals');
      wrap.innerHTML = '';
      let day = {p:0,c:0,f:0,kcal:0};

      data.meals.forEach((items, idx) => {
        const t = mealTotals(items);
        day.p += t.p; day.c += t.c; day.f += t.f; day.kcal += t.kcal;

        const rows = items.map((x,i)=>`
          <tr>
            <td>${x.name}</td>
            <td class="right">${x.grams} g</td>
            <td class="right">${x.p}</td>
            <td class="right">${x.c}</td>
            <td class="right">${x.f}</td>
            <td class="right">${x.kcal}</td>
            <td class="right"><button class="pill" data-del="${idx}:${i}">‚úï</button></td>
          </tr>
        `).join('');

        wrap.insertAdjacentHTML('beforeend', `
          <div class="card">
            <div class="meal-title">
              <strong>Meal ${idx+1}</strong>
              <span class="pill">Items: ${items.length}</span>
            </div>
            <table>
              <thead><tr>
                <th>Food</th><th class="right">Grams</th>
                <th class="right">P (g)</th><th class="right">C (g)</th><th class="right">F (g)</th>
                <th class="right">kcal</th><th></th>
              </tr></thead>
              <tbody>${rows || `<tr><td colspan="7" class="muted">No items yet.</td></tr>`}</tbody>
            </table>
            <div class="totals"><strong>Meal ${idx+1} total:</strong>
              Protein ${round1(t.p)} g ¬∑ Carbs ${round1(t.c)} g ¬∑ Fat ${round1(t.f)} g ¬∑ Calories ${t.kcal} kcal
            </div>
          </div>
        `);
      });

      $('dayTotal').innerHTML = `
        Protein <strong>${round1(day.p)}</strong> g ¬∑
        Carbs <strong>${round1(day.c)}</strong> g ¬∑
        Fat <strong>${round1(day.f)}</strong> g ¬∑
        Calories <strong>${day.kcal}</strong> kcal
      `;

      // deletions
      wrap.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.addEventListener('click',()=>{
          const [m,i] = btn.dataset.del.split(':').map(Number);
          const data = loadDay();
          data.meals[m].splice(i,1);
          saveDay(data); render();
        });
      });
    }

    $('addBtn').addEventListener('click', () => {
      const mealIdx = Number($('meal').value);
      const label = foodInput.value.trim();

      // choose from exact label if possible, else first result, else fallback list
      let it = lastResults.find(x => x.label === label) || lastResults[0];
      if (!it) {
        const fb = offlineFind(label);
        if (fb) it = { name: fb.name, p100:fb.p, c100:fb.c, f100:fb.f, gramsDefault:(fb.portions[0]?.g)||100 };
      }
      if (!it) { alert('Pick a food from the list or type a known one like ‚Äúbanana‚Äù.'); return; }

      const g = Math.max(1, Number(gramsBox.value)|| (it.gramsDefault||100) );
      const p = round1(it.p100*g/100), c = round1(it.c100*g/100), f = round1(it.f100*g/100);
      const item = { name: it.name || label, grams: g, p, c, f, kcal: kcal(p,c,f) };

      const data = loadDay();
      data.meals[mealIdx].push(item);
      saveDay(data);
      render();
      setPreviewFromItem(it);
    });

    $('resetDay').addEventListener('click', () => { localStorage.removeItem(todayKey()); render(); });

    // initial paint + a first suggestion to show the flow
    foodInput.value = 'banana';
    doSuggest();
    render();
  </script>

  <!-- Service worker registration (unchanged) -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js', { scope: './' })
          .catch(err => console.error('SW registration failed:', err));
      });
    }
  </script>
</body>
</html>



