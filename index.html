<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0ea5e9" />
  <link rel="manifest" href="manifest.json" />

  <!-- iOS home-screen icon(s) -->
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon-180.png">

  <!-- Optional: the name shown under the icon on iOS -->
  <meta name="apple-mobile-web-app-title" content="Macro App">

  <!-- Optional: open as a standalone app on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <title>Daily Macro Counter</title>
  <style>
    :root{
      --neon:#00d0ff;
      --bg1:#0b0b0b; --bg2:#121212; --bg3:#1a1a1a;
      --ok:#0f766e;      /* green-ish text */
      --low:#b45309;     /* amber */
      --high:#b91c1c;    /* red   */
    }
    body { font-family: system-ui, sans-serif; margin: 0; background:#fff; }
    .app-header{
      background: linear-gradient(135deg, var(--bg1), var(--bg2), var(--bg3));
      padding: 18px 20px;
      margin: 0 0 20px 0;
    }
    .app-title{
      margin: 0; font-weight: 700; letter-spacing:.2px;
      color: var(--neon);
      text-shadow: 0 0 8px rgba(0,208,255,.75), 0 0 16px rgba(0,208,255,.35);
    }

    .container{ margin: 0 auto; padding: 0 20px 32px; max-width: 720px; }
    .muted { color:#555; font-size:.9rem; margin-bottom:1rem; }
    .row { display:grid; grid-template-columns: 0.9fr 1.6fr 0.7fr 0.8fr auto; gap:.5rem; align-items:end; }
    label { font-size:.9rem; }
    input, select { width:100%; padding:.55rem; border:1px solid #ccc; border-radius:.5rem; }
    #portion{ max-width:120px; } /* smaller portion select for mobile fit */
    button { padding:.6rem 1rem; border:1px solid #ddd; border-radius:.7rem; cursor:pointer; background:#fff; }
    .card { padding:1rem; border:1px solid #ddd; border-radius:.75rem; margin-bottom:1rem; background:#fff; }
    table { width:100%; border-collapse: collapse; margin-top:.5rem; }
    th, td { padding:.5rem; border-bottom:1px solid #eee; text-align:left; }
    th.right, td.right { text-align:right; }
    .totals { background:#f7f7f7; border-radius:.5rem; padding:.6rem .8rem; margin-top:.5rem; }
    .meal-title { display:flex; justify-content:space-between; align-items:center; }
    .pill { font-size:.8rem; padding:.2rem .5rem; border:1px solid #ddd; border-radius:999px; background:#fff; }
    .hint { font-size:.8rem; color:#666; margin-top:.25rem; }
    .error { color:#b00020; font-size:.9rem; }
    .targets small{ color:#666; }
    .stat { font-weight:600; }
    .stat.ok { color: var(--ok); }
    .stat.low { color: var(--low); }
    .stat.high{ color: var(--high); }

    .section-title{ display:flex; justify-content:space-between; align-items:center; margin-bottom:.5rem; }
    #historyCard ul{ list-style:none; padding-left:0; margin:0; }
    #historyCard li{ padding:.45rem .25rem; border-bottom:1px dashed #e6e6e6; font-size:.95rem; }
    #historyBtn{ margin-left:.5rem; }

    @media (max-width: 520px){
      .row{ grid-template-columns: 1fr 1fr; }
      #portion{ max-width: 100%; }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <h1 class="app-title">Daily Macro Counter</h1>
  </header>

  <div class="container">
    <p class="muted">
      Pick a meal (1–6). Start typing a food (we query Open Food Facts), choose a portion or grams, then <strong>Add</strong>.
      Works offline; when offline we use a tiny built-in list.
    </p>

    <!-- Input card -->
    <div class="card">
      <div class="row">
        <div>
          <label>Meal</label>
          <select id="meal">
            <option value="0">Meal 1</option><option value="1">Meal 2</option>
            <option value="2">Meal 3</option><option value="3">Meal 4</option>
            <option value="4">Meal 5</option><option value="5">Meal 6</option>
          </select>
        </div>

        <div>
          <label>Food</label>
          <input id="foodInput" list="foodlist" placeholder="e.g., banana, oats, pasta cooked">
          <datalist id="foodlist"></datalist>
          <div id="netMsg" class="hint"></div>
        </div>

        <div>
          <label>Portion</label>
          <select id="portion"></select>
        </div>

        <div>
          <label>Grams</label>
          <input id="grams" type="number" min="1" step="1" value="100">
        </div>

        <div>
          <button id="addBtn">Add</button>
        </div>
      </div>

      <!-- Presets -->
      <div style="margin-top:.75rem; display:flex; gap:.5rem; align-items:center;">
        <label class="muted" style="margin:0;">Preset:</label>
        <select id="presetSel" style="max-width:220px;">
          <option value="morning_oats">Morning Oats (P31 · C70.4 · F10.7)</option>
        </select>
        <button id="addPresetBtn">Add Preset to Meal</button>
      </div>

      <div id="preview" class="totals" style="display:none;"></div>
      <div id="err" class="error" style="display:none;"></div>
    </div>

    <!-- Day total (now shown ABOVE the meals) -->
    <div class="card">
      <div class="section-title">
        <strong>Day total</strong>
        <div>
          <button id="historyBtn" class="pill">History (90d)</button>
          <button id="resetDay" class="pill">Reset today</button>
        </div>
      </div>
      <div id="dayTotal" class="totals"></div>
      <div class="targets" style="margin-top:.5rem;">
        <small>Targets — Carbs 324–405 g · Protein 115–146 g · Fat 65–97 g · Calories 2330–3080 kcal</small>
      </div>
    </div>

    <!-- Meals appear only when they have items -->
    <div id="meals"></div>

    <!-- History viewer -->
    <div id="historyCard" class="card" style="display:none;">
      <div class="section-title">
        <strong>History (last 90 days)</strong>
        <button id="closeHistory" class="pill">Hide</button>
      </div>
      <ul id="historyList"></ul>
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const $ = id => document.getElementById(id);

    // Local date (user’s timezone) -> "YYYY-MM-DD"
    function localDateStr(d = new Date()){
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    const todayKey = () => 'meals-' + localDateStr();

    const kcal = (p,c,f) => Math.round(p*4 + c*4 + f*9);
    const round1 = x => Math.round(x*10)/10;
    const online = () => navigator.onLine;

    function defaultDay(){ return { meals:[[],[],[],[],[],[]] }; }
    function loadDay(){ try{ return JSON.parse(localStorage.getItem(todayKey())) || defaultDay(); } catch { return defaultDay(); } }
    function saveDay(data){
      localStorage.setItem(todayKey(), JSON.stringify(data));
      localStorage.setItem('lastActiveDate', localDateStr());
    }

    // Targets (ranges)
    const TARGETS = {
      c: {min:324, max:405},   // carbs
      p: {min:115, max:146},   // protein
      f: {min:65,  max:97},    // fat
      kcal: {min:2330, max:3080}
    };
    const statusOf = (val, {min,max}) => val < min ? 'low' : (val > max ? 'high' : 'ok');

    // History (90 days)
    function historyIndex(){ return JSON.parse(localStorage.getItem('historyIndex')||'[]'); }
    function setHistoryIndex(arr){ localStorage.setItem('historyIndex', JSON.stringify(arr)); }
    function saveHistoryEntry(dateStr, totals){
      let idx = historyIndex();
      if (!idx.includes(dateStr)) idx.push(dateStr);
      // keep only last 90 (oldest first)
      idx.sort(); // chronological
      while (idx.length > 90){
        const old = idx.shift();
        localStorage.removeItem('history:'+old);
      }
      setHistoryIndex(idx);
      localStorage.setItem('history:'+dateStr, JSON.stringify(totals));
    }
    // If last active date is yesterday (or older), archive it once
    (function ensurePreviousDayArchived(){
      const today = localDateStr();
      const last = localStorage.getItem('lastActiveDate');
      if (last && last !== today){
        const prev = JSON.parse(localStorage.getItem('meals-'+last) || 'null');
        if (prev){
          const totals = prev.meals.flat().reduce((t,x)=>({p:t.p+x.p,c:t.c+x.c,f:t.f+x.f,kcal:t.kcal+x.kcal}), {p:0,c:0,f:0,kcal:0});
          saveHistoryEntry(last, totals);
        }
      }
      localStorage.setItem('lastActiveDate', today);
    })();

    // Built-in fallback foods (used when offline or API fails)
    const FALLBACK_FOODS = [
      {name:'Banana', p:1.1, c:23.0, f:0.3, portions:[{label:'100 g',g:100},{label:'1 medium (118 g)',g:118}]},
      {name:'Oats (dry)', p:13.2, c:67.7, f:6.5, portions:[{label:'100 g',g:100},{label:'Bowl (60 g)',g:60}]},
      {name:'Pasta (cooked)', p:5.8, c:30.0, f:1.1, portions:[{label:'100 g',g:100},{label:'Plate (250 g)',g:250}]}
    ];

    // ---------- Open Food Facts search ----------
    const OFF_BASE = 'https://world.openfoodfacts.org/cgi/search.pl';
    let lastResults = []; // latest suggestions for current query

    // Make a nice label and normalize nutriments (per 100g)
    function normalizeProduct(p){
      const name = (p.product_name || 'Unnamed').trim();
      const brand = (p.brands || '').split(',')[0]?.trim();
      const label = brand ? `${name} — ${brand}` : name;

      const n = p.nutriments || {};
      const p100 = Number(n.proteins_100g) || 0;
      const c100 = Number(n.carbohydrates_100g) || 0;
      const f100 = Number(n.fat_100g) || 0;
      let kcal100 = Number(n['energy-kcal_100g']);
      if (!kcal100 && (p100||c100||f100)) kcal100 = Math.round(p100*4 + c100*4 + f100*9);

      // Parse serving size like "150 g" if present
      let servingG = null;
      const ss = (p.serving_size || '').toLowerCase();
      const m = ss.match(/([\d.]+)\s*g/);
      if (m) servingG = Number(m[1]);

      const portions = [{label:'100 g', g:100}];
      if (servingG) portions.unshift({label:`1 serving (${servingG} g)`, g:servingG});

      return { code:p.code, label, name, gramsDefault: servingG || 100, p100, c100, f100, kcal100: kcal100||null, portions };
    }

    // Debounce helper so we don't spam the API while typing
    function debounce(fn, ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

    // v1 search endpoint (supports free-text "search_terms")
    async function searchOFF(query){
      const params = new URLSearchParams({
        search_terms: query,
        search_simple: '1',
        page_size: '12',
        json: '1',
        nocache: '1',
        lc: 'en',
        fields: 'code,product_name,brands,nutriments,serving_size'
      });
      const url = `${OFF_BASE}?${params.toString()}`;
      const res = await fetch(url);
      const data = await res.json();

      const products = (data.products || [])
        .map(normalizeProduct)
        .filter(x => (x.p100 || x.c100 || x.f100)); // keep only items with macros

      lastResults = products;
      return products;
    }

    // ---------- UI wiring for search + preview ----------
    const foodInput = $('foodInput');
    const foodlist = $('foodlist');
    const portionSel = $('portion');
    const gramsBox = $('grams');
    const previewBox = $('preview');
    const errBox = $('err');
    const netMsg = $('netMsg');

    function fillPortionsPortals(item){
      portionSel.innerHTML = '';
      (item.portions||[{label:'100 g',g:100}]).forEach(p =>
        portionSel.insertAdjacentHTML('beforeend', `<option value="${p.g}">${p.label}</option>`)
      );
      gramsBox.value = item.gramsDefault || (portionSel.value || 100);
    }

    function setPreviewFromItem(item){
      const g = Math.max(1, Number(gramsBox.value)||0);
      const p = item.p100 * g/100, c = item.c100 * g/100, f = item.f100 * g/100;
      previewBox.style.display = 'block';
      previewBox.innerHTML = `<strong>Item preview</strong> — ${item.name}, ${g} g<br>
        Protein: ${round1(p)} g · Carbs: ${round1(c)} g · Fat: ${round1(f)} g<br>
        Calories: ${kcal(p,c,f)} kcal`;
      errBox.style.display = 'none';
    }

    const offlineFind = (name) => {
      const n = String(name||'').toLowerCase();
      return FALLBACK_FOODS.find(f => f.name.toLowerCase().includes(n));
    };

    const doSuggest = debounce(async () => {
      const q = foodInput.value.trim();
      if (!q) { foodlist.innerHTML=''; previewBox.style.display='none'; return; }

      // show network state
      netMsg.textContent = online() ? '' : 'Offline: using built-in foods only';

      try {
        let items = [];
        if (online()) {
          items = await searchOFF(q);
        }
        // Fallback if no API results OR offline
        if (!items.length) {
          const fb = offlineFind(q);
          if (fb) {
            const fake = { code:'fallback', label: fb.name, name: fb.name,
              gramsDefault: (fb.portions[0]?.g)||100,
              p100: fb.p, c100: fb.c, f100: fb.f,
              kcal100: Math.round(fb.p*4 + fb.c*4 + fb.f*9),
              portions: fb.portions
            };
            items = [fake];
            lastResults = items;
          }
        }

        // populate datalist
        foodlist.innerHTML = '';
        items.slice(0,12).forEach(it => {
          const opt = document.createElement('option');
          opt.value = it.label;
          foodlist.appendChild(opt);
        });

        // if we have a first item, preload its portions + preview
        if (items[0]) {
          fillPortionsPortals(items[0]);
          setPreviewFromItem(items[0]);
        } else {
          previewBox.style.display='none';
        }
      } catch (e) {
        errBox.style.display='block';
        errBox.textContent = 'Could not reach Open Food Facts. Using offline list if available.';
        // fallback
        const fb = offlineFind(q);
        if (fb) {
          const fake = { code:'fallback', label: fb.name, name: fb.name,
            gramsDefault: (fb.portions[0]?.g)||100, p100: fb.p, c100: fb.c, f100: fb.f,
            kcal100: Math.round(fb.p*4 + fb.c*4 + fb.f*9), portions: fb.portions
          };
          lastResults = [fake];
          fillPortionsPortals(fake);
          setPreviewFromItem(fake);
        }
      }
    }, 300);

    foodInput.addEventListener('input', doSuggest);
    portionSel.addEventListener('change', () => { gramsBox.value = portionSel.value; if (lastChosen) setPreviewFromItem(lastChosen); });
    gramsBox.addEventListener('input', () => { if (lastChosen) setPreviewFromItem(lastChosen); });

    // when user leaves the input, try to lock on the selected label
    let lastChosen = null;
    foodInput.addEventListener('change', () => {
      const label = foodInput.value.trim();
      const it = lastResults.find(x => x.label === label) || lastResults[0];
      if (it) { lastChosen = it; fillPortionsPortals(it); setPreviewFromItem(it); }
    });

    // ---------- Add item to meal ----------
    function mealTotals(items){
      return items.reduce((t,x)=>({p:t.p+x.p, c:t.c+x.c, f:t.f+x.f, kcal:t.kcal+x.kcal}), {p:0,c:0,f:0,kcal:0});
    }

    function render(){
      const data = loadDay();
      const wrap = $('meals');
      wrap.innerHTML = '';
      let day = {p:0,c:0,f:0,kcal:0};

      // Build cards only for meals that have items
      data.meals.forEach((items, idx) => {
        const t = mealTotals(items);
        day.p += t.p; day.c += t.c; day.f += t.f; day.kcal += t.kcal;

        if (items.length === 0) return; // skip empty meals (hidden until first add)

        const rows = items.map((x,i)=>`
          <tr>
            <td>${x.name}</td>
            <td class="right">${x.grams} g</td>
            <td class="right">${x.p}</td>
            <td class="right">${x.c}</td>
            <td class="right">${x.f}</td>
            <td class="right">${x.kcal}</td>
            <td class="right"><button class="pill" data-del="${idx}:${i}">✕</button></td>
          </tr>
        `).join('');

        wrap.insertAdjacentHTML('beforeend', `
          <div class="card">
            <div class="meal-title">
              <strong>Meal ${idx+1}</strong>
              <span class="pill">Items: ${items.length}</span>
            </div>
            <table>
              <thead><tr>
                <th>Food</th><th class="right">Grams</th>
                <th class="right">P (g)</th><th class="right">C (g)</th><th class="right">F (g)</th>
                <th class="right">kcal</th><th></th>
              </tr></thead>
              <tbody>${rows}</tbody>
            </table>
            <div class="totals"><strong>Meal ${idx+1} total:</strong>
              Protein ${round1(t.p)} g · Carbs ${round1(t.c)} g · Fat ${round1(t.f)} g · Calories ${t.kcal} kcal
            </div>
          </div>
        `);
      });

      // Save rolling history entry for today
      saveHistoryEntry(localDateStr(), {p:round1(day.p), c:round1(day.c), f:round1(day.f), kcal:day.kcal});

      // Day totals vs targets with colouring
      const pStat = statusOf(day.p, TARGETS.p);
      const cStat = statusOf(day.c, TARGETS.c);
      const fStat = statusOf(day.f, TARGETS.f);
      const kStat = statusOf(day.kcal, TARGETS.kcal);

      $('dayTotal').innerHTML = `
        <div>
          <span class="stat ${pStat}">Protein ${round1(day.p)} g</span> <small>(target ${TARGETS.p.min}–${TARGETS.p.max})</small><br>
          <span class="stat ${cStat}">Carbs ${round1(day.c)} g</span> <small>(target ${TARGETS.c.min}–${TARGETS.c.max})</small><br>
          <span class="stat ${fStat}">Fat ${round1(day.f)} g</span> <small>(target ${TARGETS.f.min}–${TARGETS.f.max})</small><br>
          <span class="stat ${kStat}">Calories ${day.kcal} kcal</span> <small>(target ${TARGETS.kcal.min}–${TARGETS.kcal.max})</small>
        </div>
      `;

      // Hook deletions (and auto-hide empty meals on next render)
      wrap.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.addEventListener('click',()=>{
          const [m,i] = btn.dataset.del.split(':').map(Number);
          const data = loadDay();
          data.meals[m].splice(i,1);
          saveDay(data); render();
        });
      });
    }

    $('addBtn').addEventListener('click', () => {
      const mealIdx = Number($('meal').value);
      const label = foodInput.value.trim();

      // choose from exact label if possible, else first result, else fallback list
      let it = lastResults.find(x => x.label === label) || lastResults[0];
      if (!it) {
        const fb = offlineFind(label);
        if (fb) it = { name: fb.name, p100:fb.p, c100:fb.c, f100:fb.f, gramsDefault:(fb.portions[0]?.g)||100 };
      }
      if (!it) { alert('Pick a food from the list or type a known one like “banana”.'); return; }

      const g = Math.max(1, Number(gramsBox.value)|| (it.gramsDefault||100) );
      const p = round1(it.p100*g/100), c = round1(it.c100*g/100), f = round1(it.f100*g/100);
      const item = { name: it.name || label, grams: g, p, c, f, kcal: kcal(p,c,f) };

      const data = loadDay();
      data.meals[mealIdx].push(item);
      saveDay(data);
      render();                // will now show the meal if it was previously hidden
      setPreviewFromItem(it);
    });

    // Preset: Morning Oats (P31 · C70.4 · F10.7)
    $('addPresetBtn').addEventListener('click', ()=>{
      const mealIdx = Number($('meal').value);
      const item = { name:'Morning Oats (preset)', grams: 0, p:31.0, c:70.4, f:10.7, kcal: kcal(31.0,70.4,10.7) };
      const data = loadDay();
      data.meals[mealIdx].push(item);
      saveDay(data);
      render();
    });

    $('resetDay').addEventListener('click', () => {
      localStorage.removeItem(todayKey());
      saveDay(defaultDay()); // also updates lastActiveDate
      render();              // meals container will be empty/hidden
    });

    // History UI
    $('historyBtn').addEventListener('click', ()=>{ renderHistory(); $('historyCard').style.display='block'; window.scrollTo({top:document.body.scrollHeight, behavior:'smooth'}); });
    $('closeHistory').addEventListener('click', ()=>{ $('historyCard').style.display='none'; });

    function renderHistory(){
      const list = $('historyList');
      const idx = historyIndex().slice().sort().reverse(); // latest first
      if (!idx.length){ list.innerHTML = `<li class="muted">No history yet.</li>`; return; }
      list.innerHTML = idx.map(d=>{
        const t = JSON.parse(localStorage.getItem('history:'+d) || '{"p":0,"c":0,"f":0,"kcal":0}');
        return `<li><strong>${d}</strong> — Protein ${t.p} g · Carbs ${t.c} g · Fat ${t.f} g · Calories ${t.kcal} kcal</li>`;
      }).join('');
    }

    // initial paint + a first suggestion to show the flow
    $('foodInput').value = 'banana';
    if (online()) { (async()=>{ try{ await searchOFF('banana'); }catch{} })(); }
    render();
  </script>

  <!-- Service worker registration (unchanged) -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js', { scope: './' })
          .catch(err => console.error('SW registration failed:', err));
      });
    }
  </script>
</body>
</html>
